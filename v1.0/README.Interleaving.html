<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Interleaving</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the notion of Interleaving can be used</a>
<a id="169" class="Comment">------------------------------------------------------------------------</a>

<a id="243" class="Symbol">{-#</a> <a id="247" class="Keyword">OPTIONS</a> <a id="255" class="Pragma">--without-K</a> <a id="267" class="Pragma">--safe</a> <a id="274" class="Symbol">#-}</a>

<a id="279" class="Keyword">module</a> <a id="286" href="README.Interleaving.html" class="Module">README.Interleaving</a> <a id="306" class="Keyword">where</a>

<a id="313" class="Keyword">open</a> <a id="318" class="Keyword">import</a> <a id="325" href="Level.html" class="Module">Level</a>
<a id="331" class="Keyword">open</a> <a id="336" class="Keyword">import</a> <a id="343" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="358" class="Keyword">hiding</a> <a id="365" class="Symbol">(</a><a id="366" href="Data.List.Base.html#8043" class="Function">filter</a><a id="372" class="Symbol">)</a>
<a id="374" class="Keyword">open</a> <a id="379" class="Keyword">import</a> <a id="386" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a>
<a id="415" class="Keyword">open</a> <a id="420" class="Keyword">import</a> <a id="427" href="Function.html" class="Module">Function</a>
<a id="436" class="Keyword">open</a> <a id="441" class="Keyword">import</a> <a id="448" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="465" class="Keyword">open</a> <a id="470" class="Keyword">import</a> <a id="477" href="Relation.Unary.html" class="Module">Relation.Unary</a>

<a id="493" class="Comment">-- In its most general form, `Interleaving` is parametrised by two relations</a>
<a id="570" class="Comment">-- `L` (for Left) and `R` (for Right). Given three lists, `xs`, `ys` and `zs`,</a>
<a id="649" class="Comment">-- a proof of `Interleaving xs ys zs` is essentially a diagram explaining how</a>
<a id="727" class="Comment">-- `zs` can be pulled apart into `xs` and `ys` in a way compatible with `L`</a>
<a id="803" class="Comment">-- and `R`. For instance:</a>

<a id="830" class="Comment">-- xs               zs               ys</a>
<a id="870" class="Comment">--</a>
<a id="873" class="Comment">-- x₁ -- L x₁ z₁ -- z₁</a>
<a id="896" class="Comment">-- x₂ -- L x₂ z₂ -- z₂</a>
<a id="919" class="Comment">--                  z₃ -- R z₃ z₁ -- y₁</a>
<a id="959" class="Comment">-- x₃ -- L x₃ z₄ -- z₄</a>
<a id="982" class="Comment">--                  z₅ -- R z₅ y₂ -- y₂</a>

<a id="1023" class="Keyword">open</a> <a id="1028" class="Keyword">import</a> <a id="1035" href="Data.List.Relation.Ternary.Interleaving.Propositional.html" class="Module">Data.List.Relation.Ternary.Interleaving.Propositional</a>

<a id="1090" class="Comment">-- The special case we will focus on here is the propositional case: both</a>
<a id="1164" class="Comment">-- `L` and ̀R` are propositional equality. Rethinking our previous example,</a>
<a id="1240" class="Comment">-- this gives us the proof that [z₁, ⋯, z₅] can be partitioned into</a>
<a id="1308" class="Comment">-- [z₁, z₂, z₄] on the one hand and [z₃, z₅] in the other.</a>

<a id="1368" class="Comment">-- One possible use case for such a relation is the definition of a very</a>
<a id="1441" class="Comment">-- precise filter function. Provided a decidable predicate `P`, it will</a>
<a id="1513" class="Comment">-- prove not only that the retained values satisfy `P` but that the ones</a>
<a id="1586" class="Comment">-- that didn&#39;t make the cut satisfy the negation of P.</a>

<a id="1642" class="Comment">-- We can make this formal by defining the following record type:</a>

<a id="1709" class="Keyword">infix</a> <a id="1715" class="Number">3</a> <a id="1717" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">_≡_⊎_</a>
<a id="1723" class="Keyword">record</a> <a id="Filter"></a><a id="1730" href="README.Interleaving.html#1730" class="Record">Filter</a> <a id="1737" class="Symbol">{</a><a id="1738" href="README.Interleaving.html#1738" class="Bound">a</a> <a id="1740" href="README.Interleaving.html#1740" class="Bound">p</a><a id="1741" class="Symbol">}</a> <a id="1743" class="Symbol">{</a><a id="1744" href="README.Interleaving.html#1744" class="Bound">A</a> <a id="1746" class="Symbol">:</a> <a id="1748" class="PrimitiveType">Set</a> <a id="1752" href="README.Interleaving.html#1738" class="Bound">a</a><a id="1753" class="Symbol">}</a> <a id="1755" class="Symbol">(</a><a id="1756" href="README.Interleaving.html#1756" class="Bound">P</a> <a id="1758" class="Symbol">:</a> <a id="1760" href="Relation.Unary.html#618" class="Function">Pred</a> <a id="1765" href="README.Interleaving.html#1744" class="Bound">A</a> <a id="1767" href="README.Interleaving.html#1740" class="Bound">p</a><a id="1768" class="Symbol">)</a> <a id="1770" class="Symbol">(</a><a id="1771" href="README.Interleaving.html#1771" class="Bound">xs</a> <a id="1774" class="Symbol">:</a> <a id="1776" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1781" href="README.Interleaving.html#1744" class="Bound">A</a><a id="1782" class="Symbol">)</a> <a id="1784" class="Symbol">:</a> <a id="1786" class="PrimitiveType">Set</a> <a id="1790" class="Symbol">(</a><a id="1791" href="README.Interleaving.html#1738" class="Bound">a</a> <a id="1793" href="Agda.Primitive.html#657" class="Primitive Operator">⊔</a> <a id="1795" href="README.Interleaving.html#1740" class="Bound">p</a><a id="1796" class="Symbol">)</a> <a id="1798" class="Keyword">where</a>
  <a id="1806" class="Keyword">constructor</a> <a id="Filter._≡_⊎_"></a><a id="1818" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">_≡_⊎_</a>
  <a id="1826" class="Keyword">field</a>
    <a id="1836" class="Comment">-- The result of running filter is two lists:</a>
    <a id="1886" class="Comment">-- * the elements we have kept</a>
    <a id="1921" class="Comment">-- * and the ones we have thrown away</a>
    <a id="1963" class="Comment">-- We leave these implicit: they can be inferred from the rest</a>
    <a id="2030" class="Symbol">{</a><a id="Filter.kept"></a><a id="2031" href="README.Interleaving.html#2031" class="Field">kept</a><a id="2035" class="Symbol">}</a>   <a id="2039" class="Symbol">:</a> <a id="2041" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="2046" href="README.Interleaving.html#1744" class="Bound">A</a>
    <a id="2052" class="Symbol">{</a><a id="Filter.thrown"></a><a id="2053" href="README.Interleaving.html#2053" class="Field">thrown</a><a id="2059" class="Symbol">}</a> <a id="2061" class="Symbol">:</a> <a id="2063" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="2068" href="README.Interleaving.html#1744" class="Bound">A</a>
    <a id="2074" class="Comment">-- There is a way for us to recover the original</a>
    <a id="2127" class="Comment">-- input by interleaving the two lists</a>
    <a id="Filter.cover"></a><a id="2170" href="README.Interleaving.html#2170" class="Field">cover</a>    <a id="2179" class="Symbol">:</a> <a id="2181" href="Data.List.Relation.Ternary.Interleaving.Propositional.html#1191" class="Function">Interleaving</a> <a id="2194" href="README.Interleaving.html#2031" class="Field">kept</a> <a id="2199" href="README.Interleaving.html#2053" class="Field">thrown</a> <a id="2206" href="README.Interleaving.html#1771" class="Bound">xs</a>
    <a id="2213" class="Comment">-- Finally, the partition was made according to the predicate</a>
    <a id="Filter.allP"></a><a id="2279" href="README.Interleaving.html#2279" class="Field">allP</a>     <a id="2288" class="Symbol">:</a> <a id="2290" href="Data.List.Relation.Unary.All.html#952" class="Datatype">All</a> <a id="2294" href="README.Interleaving.html#1756" class="Bound">P</a> <a id="2296" href="README.Interleaving.html#2031" class="Field">kept</a>
    <a id="Filter.all¬P"></a><a id="2305" href="README.Interleaving.html#2305" class="Field">all¬P</a>    <a id="2314" class="Symbol">:</a> <a id="2316" href="Data.List.Relation.Unary.All.html#952" class="Datatype">All</a> <a id="2320" class="Symbol">(</a><a id="2321" href="Relation.Unary.html#3651" class="Function">∁</a> <a id="2323" href="README.Interleaving.html#1756" class="Bound">P</a><a id="2324" class="Symbol">)</a> <a id="2326" href="README.Interleaving.html#2053" class="Field">thrown</a>

<a id="2334" class="Comment">-- Once we have this type written down, we can write the function.</a>
<a id="2401" class="Comment">-- We use an anonymous module to clean up the function&#39;s type.</a>

<a id="2465" class="Keyword">module</a> <a id="2472" href="README.Interleaving.html#2472" class="Module">_</a> <a id="2474" class="Symbol">{</a><a id="2475" href="README.Interleaving.html#2475" class="Bound">a</a> <a id="2477" href="README.Interleaving.html#2477" class="Bound">p</a><a id="2478" class="Symbol">}</a> <a id="2480" class="Symbol">{</a><a id="2481" href="README.Interleaving.html#2481" class="Bound">A</a> <a id="2483" class="Symbol">:</a> <a id="2485" class="PrimitiveType">Set</a> <a id="2489" href="README.Interleaving.html#2475" class="Bound">a</a><a id="2490" class="Symbol">}</a> <a id="2492" class="Symbol">{</a><a id="2493" href="README.Interleaving.html#2493" class="Bound">P</a> <a id="2495" class="Symbol">:</a> <a id="2497" href="Relation.Unary.html#618" class="Function">Pred</a> <a id="2502" href="README.Interleaving.html#2481" class="Bound">A</a> <a id="2504" href="README.Interleaving.html#2477" class="Bound">p</a><a id="2505" class="Symbol">}</a> <a id="2507" class="Symbol">(</a><a id="2508" href="README.Interleaving.html#2508" class="Bound">P?</a> <a id="2511" class="Symbol">:</a> <a id="2513" href="Relation.Unary.html#3349" class="Function">Decidable</a> <a id="2523" href="README.Interleaving.html#2493" class="Bound">P</a><a id="2524" class="Symbol">)</a> <a id="2526" class="Keyword">where</a>

  <a id="2535" href="README.Interleaving.html#2535" class="Function">filter</a> <a id="2542" class="Symbol">:</a> <a id="2544" class="Symbol">∀</a> <a id="2546" href="README.Interleaving.html#2546" class="Bound">xs</a> <a id="2549" class="Symbol">→</a> <a id="2551" href="README.Interleaving.html#1730" class="Record">Filter</a> <a id="2558" href="README.Interleaving.html#2493" class="Bound">P</a> <a id="2560" href="README.Interleaving.html#2546" class="Bound">xs</a>
  <a id="2565" class="Comment">-- If the list is empty, we are done.</a>
  <a id="2605" href="README.Interleaving.html#2535" class="Function">filter</a> <a id="2612" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>       <a id="2621" class="Symbol">=</a> <a id="2623" href="Data.List.Relation.Ternary.Interleaving.html#1032" class="InductiveConstructor">[]</a> <a id="2626" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">≡</a> <a id="2628" href="Data.List.Relation.Unary.All.html#1021" class="InductiveConstructor">[]</a> <a id="2631" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">⊎</a> <a id="2633" href="Data.List.Relation.Unary.All.html#1021" class="InductiveConstructor">[]</a>
  <a id="2638" href="README.Interleaving.html#2535" class="Function">filter</a> <a id="2645" class="Symbol">(</a><a id="2646" href="README.Interleaving.html#2646" class="Bound">x</a> <a id="2648" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2650" href="README.Interleaving.html#2650" class="Bound">xs</a><a id="2652" class="Symbol">)</a> <a id="2654" class="Symbol">=</a>
    <a id="2660" class="Comment">-- otherwise we start by running filter on the tail</a>
    <a id="2716" class="Keyword">let</a> <a id="2720" href="README.Interleaving.html#2720" class="Bound">xs&#39;</a> <a id="2724" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">≡</a> <a id="2726" href="README.Interleaving.html#2726" class="Bound">ps</a> <a id="2729" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">⊎</a> <a id="2731" href="README.Interleaving.html#2731" class="Bound">¬ps</a> <a id="2735" class="Symbol">=</a> <a id="2737" href="README.Interleaving.html#2535" class="Function">filter</a> <a id="2744" href="README.Interleaving.html#2650" class="Bound">xs</a> <a id="2747" class="Keyword">in</a>
    <a id="2754" class="Comment">-- And depending on whether `P` holds of the head,</a>
    <a id="2809" class="Comment">-- we cons it to the `kept` or `thrown` list.</a>
    <a id="2859" href="Function.html#3533" class="Function Operator">case</a> <a id="2864" href="README.Interleaving.html#2508" class="Bound">P?</a> <a id="2867" href="README.Interleaving.html#2646" class="Bound">x</a> <a id="2869" href="Function.html#3533" class="Function Operator">of</a> <a id="2872" class="Symbol">λ</a> <a id="2874" class="Keyword">where</a> <a id="2880" class="Comment">-- [1]</a>
      <a id="2893" class="Symbol">(</a><a id="2894" href="Relation.Nullary.html#606" class="InductiveConstructor">yes</a> <a id="2898" href="README.Interleaving.html#2898" class="Bound">p</a><a id="2899" class="Symbol">)</a> <a id="2901" class="Symbol">→</a> <a id="2903" href="Data.List.Relation.Ternary.Interleaving.Propositional.html#1295" class="InductiveConstructor">consˡ</a> <a id="2909" href="README.Interleaving.html#2720" class="Bound">xs&#39;</a> <a id="2913" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">≡</a> <a id="2915" href="README.Interleaving.html#2898" class="Bound">p</a> <a id="2917" href="Data.List.Relation.Unary.All.html#1038" class="InductiveConstructor Operator">∷</a> <a id="2919" href="README.Interleaving.html#2726" class="Bound">ps</a> <a id="2922" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">⊎</a>      <a id="2929" href="README.Interleaving.html#2731" class="Bound">¬ps</a>
      <a id="2939" class="Symbol">(</a><a id="2940" href="Relation.Nullary.html#633" class="InductiveConstructor">no</a> <a id="2943" href="README.Interleaving.html#2943" class="Bound">¬p</a><a id="2945" class="Symbol">)</a> <a id="2947" class="Symbol">→</a> <a id="2949" href="Data.List.Relation.Ternary.Interleaving.Propositional.html#1325" class="InductiveConstructor">consʳ</a> <a id="2955" href="README.Interleaving.html#2720" class="Bound">xs&#39;</a> <a id="2959" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">≡</a>     <a id="2965" href="README.Interleaving.html#2726" class="Bound">ps</a> <a id="2968" href="README.Interleaving.html#1818" class="InductiveConstructor Operator">⊎</a> <a id="2970" href="README.Interleaving.html#2943" class="Bound">¬p</a> <a id="2973" href="Data.List.Relation.Unary.All.html#1038" class="InductiveConstructor Operator">∷</a> <a id="2975" href="README.Interleaving.html#2731" class="Bound">¬ps</a>



<a id="2982" class="Comment">-- [1] See the following module for explanations of `case_of_` and</a>
<a id="3049" class="Comment">--     pattern-matching lambdas</a>
<a id="3081" class="Keyword">import</a> <a id="3088" href="README.Case.html" class="Module">README.Case</a>
</pre></body></html>